--- 
layout: post
title: "ClassLoader Memory Leak: Detection and Protection in Tomcat"
category: Java
published: true
meta: 
  _edit_last: "1"
  _wp_old_slug: memory-leak-protection-in-tomcat-7
tags: 
- Java
- servlet
- Tomcat
- Web
- !binary |
  5oCn6IO95LyY5YyW

type: post
status: publish
---
最近在tomcat 6下面重新部署应用时，发现了下面一个抛错，非常困惑，所以就研究了一下。

org.apache.catalina.loader.WebappClassLoader clearThreadLocalMap严重: The web application [/test] created a ThreadLocal with key of type [java.lang.ThreadLocal] (value [java.lang.ThreadLocal@c47498]) and a value of type [XXX] (value [XXX@1c2dad7]) but failed to remove it when the web application was stopped.

按道理，ThreadLocal在线程关闭时，会自动被垃圾回收器回收，所以一般就算不remove也没有关系，交给Thread了。那为什么这边会有抛错，非常不解, Tomcat这么做肯定有它的道理，是为了解决什么问题呢？

仔细分析后发现，Web容器中线程在不同的Request和Servlet之间是会重复利用的，包括undeploy之后deploy，线程还会存在，从某种意义上就有点像全局变量。也就是说，在应用重新部署后ThreadLocal并不会被remove，那如果ThreadLocal里面放的对象很小，毕竟是全局的，虽然一直存在，但也不至于造成什么严重的问题，Tomcat实现<a title="memory-leak-protection-tomcat" href="http://java.dzone.com/articles/memory-leak-protection-tomcat" target="_blank">Detection and Protection in Tomcat</a>是不是多此一举？

原来并非这么简单，真正的罪魁祸首是ClassLoader Memory Leak，基于如下重要事实:

<strong>0. 一般的应用服务器比如Tomcat或者Glassfish因为要实现应用的模块化，从而可以动态的undeploy或者deploy应用(.war, .ear, etc)， 并且可以实现<a title="热部署" href="http://baike.baidu.com/view/5036687.htm" target="_blank">热部署</a>，不需要重启服务器，所以每个应用都会有自己的WebappClassLoader。</strong>

<strong>1. 每一个实例对象，比如XServlet instance都保有它对应class的引用，比如XServlet.class</strong>

<strong>2. 每一个class对象，比如XServlet.class或者在XServlet里面第一次加载的class, 都会保有当前加载它的那个class loader引用，也就是当前对象的classloader.</strong>

<strong>3. 每个class loader都会保有所有它加载的class对象的引用。</strong>

就拿上面的ThreadLocal举例，因为threadLocal.get()里面引用的对象的class可能是在当前WebappClassLoader里面加载的，所以如果undeploy时，如果threadLocal没有remove，那么直接导致当前的appClassLoader及其加载的所有对象和class无法回收，结果就是Memory Leak! 如果加载的类class不断变多，占用内存超过PermGen大小，还会导致"java.lang.OutOfMemoryError: PermGen space" 异常。

<strong>结论: 如果当前应用外部保有对象的类class是在改应用的classloader中加载的，那么就会导致一个classloader泄漏。</strong>

自然，这里的当前应用外部保有的引用就包括全局引用和ThreadLocal线程作用域引用，所以不光ThreadLocal要注意，其他的地方如全局变量可能也要注意。另外，等待Web容器解决这个问题是不现实的， 我在想要不要弄一个RequestLocal代替ThreadLocal和其他全局变量。

关于ClassLoader Leaks，参考资料里面有两篇解释的非常好的文章，特别是里面举了一个全局变量的例子，非常生动：就算如下代码也是会有类似问题的。

&nbsp;
<pre escaped="true" lang="java" line="1">package com.stc.test;

import java.io.\*;
import java.util.logging.\*;
import javax.servlet.\*;
import javax.servlet.http.\*;

public class MyServlet extends HttpServlet {
protected void doGet(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
// Log at a custom level
Level customLevel = new Level("OOPS", 555) {};
Logger.getLogger("test").log(customLevel, "doGet() called");
}
}</pre>
&nbsp;

参考资料：

[1] <a href="http://blogs.oracle.com/fkieviet/entry/classloader_leaks_the_dreaded_java">http://blogs.oracle.com/fkieviet/entry/classloader_leaks_the_dreaded_java</a>

[2]<a href="http://blogs.oracle.com/fkieviet/entry/how_to_fix_the_dreaded">http://blogs.oracle.com/fkieviet/entry/how_to_fix_the_dreaded</a>

[3]<a href="http://java.dzone.com/articles/memory-leak-protection-tomcat">http://java.dzone.com/articles/memory-leak-protection-tomcat</a>

[4]<a href="http://wiki.apache.org/tomcat/MemoryLeakProtection">http://wiki.apache.org/tomcat/MemoryLeakProtection</a>

[5]<a href="http://www.iteye.com/topic/75440">http://www.iteye.com/topic/75440</a>
