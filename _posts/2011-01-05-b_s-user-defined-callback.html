--- 
layout: post
title: !binary |
  Qi9T5Lqk5LqS5pWw5o2u5pe277yM55So5oi36Ieq5a6a5LmJ5Zue6LCD5Ye9
  5pWw55qE5LiA56eN55u06KeC5pa55rOV

published: true
meta: 
  _edit_last: "1"
  _wp_old_slug: bs%e4%ba%a4%e4%ba%92%e6%95%b0%e6%8d%ae%e6%97%b6%ef%bc%8c%e7%94%a8%e6%88%b7%e8%87%aa%e5%ae%9a%e4%b9%89%e5%9b%9e%e8%b0%83%e5%87%bd%e6%95%b0%e7%9a%84%e4%b8%80%e7%a7%8d%e7%9b%b4%e8%a7%82%e6%96%b9
tags: 
- !binary |
  5YmN56uv5byA5Y+R

type: post
status: publish
---
在js中经常有各种各样的回调函数，可以让用户自定义内容，比如：

1 dosomething({
2 callback: function(res) {
3 // content
4 alert('hello world' + res)
5 }
6 })

在一个框架中，这些callback的形参往往是框架已经定义好的，调用也是由框架负责， 框架的用户唯一能做的就是改变callback函数的内容。

有时，content的数据需要由服务器生成，比如{arg1: 1, arg2, 2}是由服务器生成的，用户定义这个callback行为时并不知道这些参数的值，只知道参数的名arg1, arg2, 用户希望可以直观舒服的定义，既能取到arg1, arg2, 又能取到res,能适应不同的callback，像下面这样：

1 function(arg1, arg2, res, status) {
2 alert(arg1 + res);// 用户能定义的内容
3 }

前面已经说过，callback的形参定义和调用用户都无法介入，那怎么样才能做到这样呢?方法总是有的，下面是一种解决方案，大体的思路就是利用closure取到callback实参的值，同时将callback的实参嵌入用户定义的函数来保持arguments和形参形式的统一。Callback的形式：

1 function(res, status){${jsImpl}}

这是用户定义的代码：

1 function(arg1, arg2, res, status) {
2 // user defined
3 }()

用下面这段代码替换${jsImpl}, 其中arg1, arg2和[1, 2]是服务器端生成的：

1 ;return (
2 function(arg1, arg2) {
3 ${userDefined}
4 }
5 )
6 .createDelegate(this, [1, 2], true)
7 .apply(this, arguments)

整个的替换后就是：

01 (function(res){
02 ;return
03 (function(arg1, arg2, arg3){//abc, 1, 2
04 alert(arguments[0]);
05 alert(arguments[1]);
06 alert(arguments[2]);
07 alert(res);
08 alert(arg1);
09 alert(arg2);
10 alert(arg3);
11 })
12 .createDelegate(this, [1, 2], 0)
13 .apply(this, arguments)
14 })
15 .apply(window, ["abc"])

有人可能会问，如果只是要取到callback参数的值为什么不简单一点：

01 (function(res){
02 //...
03 ;return
04 (function(arg1, arg2, arg3){//abc, 1, 2
05 alert(arguments[0]);
06 alert(arguments[1]);
07 alert(arguments[2]);
08 alert(res);
09 alert(arg1);
10 alert(arg2);
11 alert(arg3);
12 }).call(this, 1, 2);
13 })
14 .apply(window, ["abc"])

不这样的原因，主要是形参和arguments形式上就不统一了，以防有人用arguments取参数值，谈到arguments, 这边还要注意如果是取原来callback的第i个参数的话，需要加上形参的个数arguments[2+i]，2为用户自定义的形参个数。

PS: createDelegate请看<a href="http://www.extjs.com/learn/Manual:Utilities:Function_(Chinese)" target="_blank">http://www.extjs.com/learn/Manual:Utilities:Function_(Chinese)</a>
